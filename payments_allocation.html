<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payment Allocation - Sugar</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .container {
            padding: 0;
            margin: 0;
            width: 100%;
        }

        .allocation-container {
            max-width: none;
            margin: 0;
            width: 100%;
            padding: 1rem;
        }

        .tenant-card {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 1rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tenant-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .tenant-name {
            font-size: 1.4rem;
            font-weight: 600;
        }

        .room-info {
            opacity: 0.6;
            font-size: 0.9rem;
        }

        .deposit-summary {
            font-size: 1.2rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: baseline;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            padding-left: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .allocation-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .allocation-item {
            background: #1e293b;
            padding: 1.2rem;
            border-radius: 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-type {
            font-weight: 600;
            color: #a5b4fc;
        }

        .item-month {
            font-size: 0.85rem;
            opacity: 0.6;
        }

        .amount-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .due-info {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .wheel-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.3rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .wheel-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 0.3rem;
            border: none;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .wheel-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .amount-input {
            width: 120px;
            background: transparent;
            border: none;
            color: white;
            text-align: right;
            font-size: 1.1rem;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
        }

        .amount-input:focus {
            outline: none;
        }

        .footer-actions {
            position: sticky;
            bottom: 1rem;
            margin-top: 3rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            display: flex;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-save {
            width: 100%;
            max-width: 400px;
            padding: 1rem;
            font-size: 1.1rem;
            font-weight: 600;
            background: #10b981;
            color: white;
            border-radius: 0.8rem;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.3);
        }

        .remaining-badge {
            font-size: 0.8rem;
            padding: 0.2rem 0.6rem;
            border-radius: 1rem;
            background: rgba(248, 113, 113, 0.1);
            color: #f87171;
            font-weight: 400;
        }
    </style>
</head>

<body class="has-back-button">
    <!-- Navbar -->

    <div class="allocation-container">
        <div class="tenant-card">
            <div class="tenant-info">
                <div>
                    <div class="tenant-name" id="tenant-name">세입자명</div>
                    <div class="room-info" id="room-info">건물명 000호</div>
                </div>
                <div style="text-align: right;">
                    <div style="font-size:0.8rem; opacity:0.6; margin-bottom:0.2rem;">총 입금액</div>
                    <div style="font-size:1.5rem; font-weight:600; color:#4ade80;" id="total-deposit">0원</div>
                </div>
            </div>
            <div class="deposit-summary" id="deposit-balance">
                <!-- Balance summary -->
            </div>
        </div>

        <div class="section-title">
            <span>배정 내역</span>
            <div id="remaining-amount" class="remaining-badge">남은 금액: 0원</div>
        </div>

        <div id="allocation-list" class="allocation-list">
            <!-- Driven by JS -->
        </div>

        <div class="footer-actions">
            <button class="btn-save" onclick="saveAllocation()">저장 및 완료</button>
        </div>
    </div>

    <script src="/js/common.js"></script>
    <script>
        const user = JSON.parse(localStorage.getItem('user'));
        const pendingData = JSON.parse(sessionStorage.getItem('pending_payment'));
        let contractDetail = null;
        let ledgerData = [];
        let allocations = [];
        let totalReceived = 0;

        document.addEventListener('DOMContentLoaded', async () => {
            if (!user) { window.location.href = '/index.html'; return; }
            if (!pendingData) { window.location.href = 'payments.html'; return; }

            renderNavbar();
            totalReceived = pendingData.amount;

            document.getElementById('tenant-name').textContent = pendingData.nickname;
            document.getElementById('room-info').textContent = `${pendingData.building} ${pendingData.room_number}호`;
            document.getElementById('total-deposit').textContent = totalReceived.toLocaleString() + '원';

            await loadData();
            calculateAllocation();
            renderAllocations();
        });

        async function loadData() {
            try {
                // 1. Fetch contract detail
                const contractRes = await fetch(`/api/landlord/${user.id}/contracts/active`);
                if (contractRes.ok) {
                    const active = await contractRes.json();
                    contractDetail = active.find(c => c.id === pendingData.contract_id);
                }

                // 2. Fetch ledger (unpaid invoices)
                const ledgerRes = await fetch(`/api/payments/ledger?role=landlord&user_id=${user.id}&tenant_id=${pendingData.tenant_id}`);
                if (ledgerRes.ok) {
                    ledgerData = await ledgerRes.json();
                }

                // 3. Display Deposit balance
                if (contractDetail) {
                    const depositInvoices = ledgerData.filter(i => (i.invoice_type & 1) === 1);
                    const paidDeposit = depositInvoices.reduce((sum, i) => sum + (i.paid_amount || 0), 0);
                    const totalDeposit = contractDetail.deposit || 0;
                    const balance = totalDeposit - paidDeposit;

                    const balanceEl = document.getElementById('deposit-balance');
                    if (balance > 0) {
                        balanceEl.innerHTML = `
                            <span>보증금 잔액</span>
                            <span style="font-weight:600; color:#f87171;">-${balance.toLocaleString()}원</span>
                        `;
                    } else {
                        balanceEl.innerHTML = `
                            <span>보증금 잔액</span>
                            <span style="font-weight:600; color:#4ade80;">완납</span>
                        `;
                    }
                }
            } catch (e) {
                console.error(e);
            }
        }

        function calculateDueDate(type, billMonth) {
            if (!contractDetail || !contractDetail.contract_start_date) return null;

            const startDate = contractDetail.contract_start_date; // YYYY-MM-DD
            const startDay = startDate.slice(8, 10);

            if (type === 'deposit' || (type & 1)) {
                return startDate;
            }

            // For Rent/Maintenance Fee
            const isPostpaid = contractDetail.payment_type === 'postpaid';
            let [y, m] = billMonth.split('-').map(Number);

            if (isPostpaid) {
                m++;
                if (m > 12) { m = 1; y++; }
            }

            // Result date: YYYY-MM-DD where DD comes from start date
            // Note: If start day is 31 and next month has 30, we should handle it, but simple slice/join for now.
            const targetMonth = `${y}-${String(m).padStart(2, '0')}`;
            return `${targetMonth}-${startDay}`;
        }

        function calculateAllocation() {
            let remaining = totalReceived;
            allocations = [];

            // 1. Prioritize Security Deposit (보증금)
            if (contractDetail) {
                const depositInvoices = ledgerData.filter(i => i.invoice_type === 'deposit' || (i.invoice_type & 1));
                const paidDepositTotal = depositInvoices.reduce((sum, i) => sum + (i.paid_amount || 0), 0);
                const totalDepositOwed = contractDetail.deposit || 0;

                // Check if there is an active (unpaid) deposit invoice in the ledger
                const existingUnpaidDeposit = ledgerData.find(i => (i.invoice_type === 'deposit' || (i.invoice_type & 1)) && (i.due_amount - i.paid_amount) > 0);

                if (paidDepositTotal < totalDepositOwed && !existingUnpaidDeposit) {
                    const owed = totalDepositOwed - paidDepositTotal;
                    const allocate = Math.min(remaining, owed);

                    if (allocate > 0) {
                        const bMonth = contractDetail.contract_start_date ? contractDetail.contract_start_date.slice(0, 7) : new Date().toISOString().slice(0, 7);
                        allocations.push({
                            invoice_id: null,
                            type: 'deposit',
                            bill_month: bMonth,
                            due_date: calculateDueDate('deposit', bMonth),
                            due_total: totalDepositOwed,
                            already_paid: paidDepositTotal,
                            amount: allocate
                        });
                        remaining -= allocate;
                    }
                }
            }

            // 2. Handle existing unpaid invoices (Arrears)
            const unpaidSorted = [...ledgerData]
                .filter(i => (i.due_amount - i.paid_amount) > 0)
                .sort((a, b) => {
                    const aIsDep = a.invoice_type === 'deposit' || (a.invoice_type & 1);
                    const bIsDep = b.invoice_type === 'deposit' || (b.invoice_type & 1);
                    if (aIsDep !== bIsDep) {
                        return aIsDep ? -1 : 1;
                    }
                    return a.bill_month.localeCompare(b.bill_month);
                });

            unpaidSorted.forEach(inv => {
                if (remaining <= 0) return;
                const owed = inv.due_amount - inv.paid_amount;
                const allocate = Math.min(remaining, owed);

                allocations.push({
                    invoice_id: inv.id,
                    type: inv.invoice_type,
                    bill_month: inv.bill_month,
                    due_date: inv.due_date,
                    due_total: inv.due_amount,
                    already_paid: inv.paid_amount,
                    amount: allocate
                });
                remaining -= allocate;
            });

            // 3. Excess amount to next month's Rent
            if (remaining > 0) {
                let nextMonth = getNextBillMonth();
                allocations.push({
                    invoice_id: null, // New
                    type: 'monthly_rent',
                    bill_month: nextMonth,
                    due_date: calculateDueDate('monthly_rent', nextMonth),
                    due_total: contractDetail ? contractDetail.monthly_rent : 0,
                    already_paid: 0,
                    amount: remaining
                });
                remaining = 0;
            }

            // Final Sort: Deposit first, then by bill month
            allocations.sort((a, b) => {
                const aIsDeposit = a.type === 'deposit' || (a.type & 1);
                const bIsDeposit = b.type === 'deposit' || (b.type & 1);
                if (aIsDeposit !== bIsDeposit) {
                    return aIsDeposit ? -1 : 1;
                }
                return a.bill_month.localeCompare(b.bill_month);
            });

            updateRemainingDisplay();
        }

        function getNextBillMonth() {
            if (ledgerData.length > 0) {
                const max = ledgerData.reduce((prev, curr) => curr.bill_month > prev ? curr.bill_month : prev, '0000-00');
                const [y, m] = max.split('-').map(Number);
                let nextY = y, nextM = m + 1;
                if (nextM > 12) { nextY++; nextM = 1; }
                return `${nextY}-${String(nextM).padStart(2, '0')}`;
            }
            return new Date().toISOString().slice(0, 7);
        }

        function renderAllocations() {
            const list = document.getElementById('allocation-list');
            list.innerHTML = '';

            allocations.forEach((alloc, idx) => {
                const item = document.createElement('div');
                item.className = 'allocation-item';

                let typeName = '기타';
                if (alloc.type === 'deposit' || (alloc.type & 1)) typeName = '보증금';
                else if (alloc.type === 'monthly_rent' || (alloc.type & 2)) typeName = '월세';
                else if (alloc.type === 'maintenance_fee' || (alloc.type & 4)) typeName = '관리비';

                const unpaid = alloc.due_total - alloc.already_paid;
                const dueDateDisp = alloc.due_date ? ` (${alloc.due_date.slice(5)})` : '';

                item.innerHTML = `
                    <div class="item-header">
                        <div>
                            <span class="item-type">${typeName}</span>
                            <span class="item-month">${alloc.bill_month}${dueDateDisp}</span>
                        </div>
                        <div class="due-info">청구: ${alloc.due_total.toLocaleString()}원</div>
                    </div>
                    <div class="amount-row">
                        <div style="font-size:0.85rem; opacity:0.5;">배정 금액</div>
                        <div class="wheel-input">
                            <button class="wheel-btn" onclick="adjustAmount(${idx}, -10000)">-</button>
                            <input type="text" class="amount-input" value="${alloc.amount.toLocaleString()}" 
                                   onchange="manualUpdate(${idx}, this.value)">
                            <button class="wheel-btn" onclick="adjustAmount(${idx}, 10000)">+</button>
                        </div>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function adjustAmount(idx, delta) {
            allocations[idx].amount = Math.max(0, allocations[idx].amount + delta);
            updateRemainingDisplay();
            renderAllocations();
        }

        function manualUpdate(idx, val) {
            const num = parseInt(val.replace(/,/g, ''), 10) || 0;
            allocations[idx].amount = num;
            updateRemainingDisplay();
            renderAllocations();
        }

        function updateRemainingDisplay() {
            const currentTotal = allocations.reduce((sum, a) => sum + a.amount, 0);
            const diff = totalReceived - currentTotal;
            const badge = document.getElementById('remaining-amount');

            if (diff === 0) {
                badge.textContent = '배정 완료';
                badge.style.background = 'rgba(16, 185, 129, 0.1)';
                badge.style.color = '#10b981';
            } else if (diff > 0) {
                badge.textContent = `남은 금액: ${diff.toLocaleString()}원`;
                badge.style.background = 'rgba(248, 113, 113, 0.1)';
                badge.style.color = '#f87171';
            } else {
                badge.textContent = `초과 금액: ${Math.abs(diff).toLocaleString()}원`;
                badge.style.background = 'rgba(239, 68, 68, 0.2)';
                badge.style.color = '#ef4444';
            }
        }

        async function saveAllocation() {
            const currentTotal = allocations.reduce((sum, a) => sum + a.amount, 0);
            if (currentTotal !== totalReceived) {
                if (!confirm(`총 입금액(${totalReceived.toLocaleString()}원)과 배정 합계(${currentTotal.toLocaleString()}원)가 일치하지 않습니다. 그래도 저장하시겠습니까?`)) {
                    return;
                }
            }

            const payload = {
                contract_id: pendingData.contract_id,
                amount: totalReceived,
                paid_at: pendingData.date,
                memo: pendingData.originalText,
                allocations: allocations.map(a => ({
                    invoice_id: a.invoice_id,
                    type: a.type,
                    bill_month: a.bill_month,
                    amount: a.amount
                }))
            };

            try {
                const res = await fetch('/api/payments/allocate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    alert('성공적으로 저장되었습니다.');
                    sessionStorage.removeItem('pending_payment');
                    window.location.href = 'payments.html';
                } else {
                    const errTxt = await res.text();
                    alert('저장 실패: ' + errTxt);
                }
            } catch (e) {
                console.error(e);
                alert('요청 중 오류 발생');
            }
        }
    </script>
</body>

</html>